/*
 * This file is generated by jOOQ.
 */
package generated.jooq.tables


import generated.jooq.Public
import generated.jooq.enums.OAuthConnectionStatus
import generated.jooq.enums.OAuthConnectionType
import generated.jooq.enums.OAuthProvider
import generated.jooq.indexes.IDX_OAUTH_CONNECTIONS_CHARTER_ID
import generated.jooq.indexes.IDX_OAUTH_CONNECTIONS_CREATED_BY
import generated.jooq.indexes.IDX_OAUTH_CONNECTIONS_PROVIDER
import generated.jooq.indexes.IDX_OAUTH_CONNECTIONS_STATUS
import generated.jooq.indexes.IDX_OAUTH_CONNECTIONS_TYPE
import generated.jooq.indexes.IDX_OAUTH_CONNECTIONS_VESSEL_ID
import generated.jooq.indexes.IDX_OAUTH_CONNECTIONS_VESSEL_STATUS
import generated.jooq.keys.OAUTH_CONNECTIONS_PKEY
import generated.jooq.keys.OAUTH_CONNECTIONS__FK_OAUTH_CONNECTIONS_USER
import generated.jooq.keys.OAUTH_CONNECTIONS__FK_OAUTH_CONNECTIONS_VESSEL
import generated.jooq.keys.OAUTH_CONNECTION_GRANTS__FK_OAUTH_GRANTS_CONNECTION
import generated.jooq.keys.OAUTH_CREDENTIALS__FK_OAUTH_CREDENTIALS_CONNECTION
import generated.jooq.tables.OAuthConnectionGrants.OauthConnectionGrantsPath
import generated.jooq.tables.OAuthCredentials.OauthCredentialsPath
import generated.jooq.tables.Users.UsersPath
import generated.jooq.tables.Vessels.VesselsPath
import generated.jooq.tables.records.OAuthConnectionsRecord

import io.vertx.core.shareddata.ClusterSerializable

import java.time.OffsetDateTime
import java.util.UUID

import kotlin.collections.Collection
import kotlin.collections.List

import nl.clicqo.data.JooqJsonbObjectBinding

import org.jooq.Check
import org.jooq.Condition
import org.jooq.Field
import org.jooq.ForeignKey
import org.jooq.Index
import org.jooq.InverseForeignKey
import org.jooq.Name
import org.jooq.Path
import org.jooq.PlainSQL
import org.jooq.QueryPart
import org.jooq.Record
import org.jooq.SQL
import org.jooq.Schema
import org.jooq.Select
import org.jooq.Stringly
import org.jooq.Table
import org.jooq.TableField
import org.jooq.TableOptions
import org.jooq.UniqueKey
import org.jooq.impl.DSL
import org.jooq.impl.Internal
import org.jooq.impl.SQLDataType
import org.jooq.impl.TableImpl


/**
 * OAuth integrations at charter/vessel level. Contains connection metadata and
 * display information. Credentials are stored separately in oauth_credentials.
 */
@Suppress("warnings")
open class OAuthConnections(
    alias: Name,
    path: Table<out Record>?,
    childPath: ForeignKey<out Record, OAuthConnectionsRecord>?,
    parentPath: InverseForeignKey<out Record, OAuthConnectionsRecord>?,
    aliased: Table<OAuthConnectionsRecord>?,
    parameters: Array<Field<*>?>?,
    where: Condition?
): TableImpl<OAuthConnectionsRecord>(
    alias,
    Public.PUBLIC,
    path,
    childPath,
    parentPath,
    aliased,
    parameters,
    DSL.comment("OAuth integrations at charter/vessel level. Contains connection metadata and display information. Credentials are stored separately in oauth_credentials."),
    TableOptions.table(),
    where,
) {
    companion object {

        /**
         * The reference instance of <code>public.oauth_connections</code>
         */
        val OAUTH_CONNECTIONS: OAuthConnections = OAuthConnections()
    }

    /**
     * The class holding records for this type
     */
    override fun getRecordType(): Class<OAuthConnectionsRecord> = OAuthConnectionsRecord::class.java

    /**
     * The column <code>public.oauth_connections.id</code>.
     */
    val ID: TableField<OAuthConnectionsRecord, UUID?> = createField(DSL.name("id"), SQLDataType.UUID.nullable(false).defaultValue(DSL.field(DSL.raw("uuid_generate_v4()"), SQLDataType.UUID)), this, "")

    /**
     * The column <code>public.oauth_connections.vessel_id</code>.
     */
    val VESSEL_ID: TableField<OAuthConnectionsRecord, UUID?> = createField(DSL.name("vessel_id"), SQLDataType.UUID, this, "")

    /**
     * The column <code>public.oauth_connections.charter_id</code>.
     */
    val CHARTER_ID: TableField<OAuthConnectionsRecord, UUID?> = createField(DSL.name("charter_id"), SQLDataType.UUID, this, "")

    /**
     * The column <code>public.oauth_connections.type</code>.
     */
    val TYPE: TableField<OAuthConnectionsRecord, OAuthConnectionType?> = createField(DSL.name("type"), SQLDataType.VARCHAR.nullable(false).asEnumDataType(OAuthConnectionType::class.java), this, "")

    /**
     * The column <code>public.oauth_connections.provider</code>.
     */
    val PROVIDER: TableField<OAuthConnectionsRecord, OAuthProvider?> = createField(DSL.name("provider"), SQLDataType.VARCHAR.nullable(false).asEnumDataType(OAuthProvider::class.java), this, "")

    /**
     * The column <code>public.oauth_connections.status</code>.
     */
    val STATUS: TableField<OAuthConnectionsRecord, OAuthConnectionStatus?> = createField(DSL.name("status"), SQLDataType.VARCHAR.nullable(false).defaultValue(DSL.field(DSL.raw("'pending'::oauth_connection_status"), SQLDataType.VARCHAR)).asEnumDataType(OAuthConnectionStatus::class.java), this, "")

    /**
     * The column <code>public.oauth_connections.display_name</code>.
     * User-friendly name, e.g., "GitHub (Acme Org)"
     */
    val DISPLAY_NAME: TableField<OAuthConnectionsRecord, String?> = createField(DSL.name("display_name"), SQLDataType.CLOB, this, "User-friendly name, e.g., \"GitHub (Acme Org)\"")

    /**
     * The column <code>public.oauth_connections.created_by_user_id</code>.
     */
    val CREATED_BY_USER_ID: TableField<OAuthConnectionsRecord, UUID?> = createField(DSL.name("created_by_user_id"), SQLDataType.UUID.nullable(false), this, "")

    /**
     * The column <code>public.oauth_connections.created_at</code>.
     */
    val CREATED_AT: TableField<OAuthConnectionsRecord, OffsetDateTime?> = createField(DSL.name("created_at"), SQLDataType.TIMESTAMPWITHTIMEZONE(6).nullable(false).defaultValue(DSL.field(DSL.raw("now()"), SQLDataType.TIMESTAMPWITHTIMEZONE)), this, "")

    /**
     * The column <code>public.oauth_connections.updated_at</code>.
     */
    val UPDATED_AT: TableField<OAuthConnectionsRecord, OffsetDateTime?> = createField(DSL.name("updated_at"), SQLDataType.TIMESTAMPWITHTIMEZONE(6).nullable(false).defaultValue(DSL.field(DSL.raw("now()"), SQLDataType.TIMESTAMPWITHTIMEZONE)), this, "")

    /**
     * The column <code>public.oauth_connections.last_validated_at</code>.
     */
    val LAST_VALIDATED_AT: TableField<OAuthConnectionsRecord, OffsetDateTime?> = createField(DSL.name("last_validated_at"), SQLDataType.TIMESTAMPWITHTIMEZONE(6), this, "")

    /**
     * The column <code>public.oauth_connections.scopes</code>. OAuth scopes
     * granted for this connection
     */
    val SCOPES: TableField<OAuthConnectionsRecord, ClusterSerializable?> = createField(DSL.name("scopes"), SQLDataType.JSONB, this, "OAuth scopes granted for this connection", JooqJsonbObjectBinding())

    /**
     * The column <code>public.oauth_connections.provider_account_id</code>.
     * External provider account/org ID
     */
    val PROVIDER_ACCOUNT_ID: TableField<OAuthConnectionsRecord, String?> = createField(DSL.name("provider_account_id"), SQLDataType.CLOB, this, "External provider account/org ID")

    private constructor(alias: Name, aliased: Table<OAuthConnectionsRecord>?): this(alias, null, null, null, aliased, null, null)
    private constructor(alias: Name, aliased: Table<OAuthConnectionsRecord>?, parameters: Array<Field<*>?>?): this(alias, null, null, null, aliased, parameters, null)
    private constructor(alias: Name, aliased: Table<OAuthConnectionsRecord>?, where: Condition?): this(alias, null, null, null, aliased, null, where)

    /**
     * Create an aliased <code>public.oauth_connections</code> table reference
     */
    constructor(alias: String): this(DSL.name(alias))

    /**
     * Create an aliased <code>public.oauth_connections</code> table reference
     */
    constructor(alias: Name): this(alias, null)

    /**
     * Create a <code>public.oauth_connections</code> table reference
     */
    constructor(): this(DSL.name("oauth_connections"), null)

    constructor(path: Table<out Record>, childPath: ForeignKey<out Record, OAuthConnectionsRecord>?, parentPath: InverseForeignKey<out Record, OAuthConnectionsRecord>?): this(Internal.createPathAlias(path, childPath, parentPath), path, childPath, parentPath, OAUTH_CONNECTIONS, null, null)

    /**
     * A subtype implementing {@link Path} for simplified path-based joins.
     */
    open class OauthConnectionsPath : OAuthConnections, Path<OAuthConnectionsRecord> {
        constructor(path: Table<out Record>, childPath: ForeignKey<out Record, OAuthConnectionsRecord>?, parentPath: InverseForeignKey<out Record, OAuthConnectionsRecord>?): super(path, childPath, parentPath)
        private constructor(alias: Name, aliased: Table<OAuthConnectionsRecord>): super(alias, aliased)
        override fun `as`(alias: String): OauthConnectionsPath = OauthConnectionsPath(DSL.name(alias), this)
        override fun `as`(alias: Name): OauthConnectionsPath = OauthConnectionsPath(alias, this)
        override fun `as`(alias: Table<*>): OauthConnectionsPath = OauthConnectionsPath(alias.qualifiedName, this)
    }
    override fun getSchema(): Schema? = if (aliased()) null else Public.PUBLIC
    override fun getIndexes(): List<Index> = listOf(IDX_OAUTH_CONNECTIONS_CHARTER_ID, IDX_OAUTH_CONNECTIONS_CREATED_BY, IDX_OAUTH_CONNECTIONS_PROVIDER, IDX_OAUTH_CONNECTIONS_STATUS, IDX_OAUTH_CONNECTIONS_TYPE, IDX_OAUTH_CONNECTIONS_VESSEL_ID, IDX_OAUTH_CONNECTIONS_VESSEL_STATUS)
    override fun getPrimaryKey(): UniqueKey<OAuthConnectionsRecord> = OAUTH_CONNECTIONS_PKEY
    override fun getReferences(): List<ForeignKey<OAuthConnectionsRecord, *>> = listOf(OAUTH_CONNECTIONS__FK_OAUTH_CONNECTIONS_USER, OAUTH_CONNECTIONS__FK_OAUTH_CONNECTIONS_VESSEL)

    /**
     * Get the implicit join path to the <code>public.users</code> table.
     */
    fun users(): UsersPath = users
    val users: UsersPath by lazy { UsersPath(this, OAUTH_CONNECTIONS__FK_OAUTH_CONNECTIONS_USER, null) }

    /**
     * Get the implicit join path to the <code>public.vessels</code> table.
     */
    fun vessels(): VesselsPath = vessels
    val vessels: VesselsPath by lazy { VesselsPath(this, OAUTH_CONNECTIONS__FK_OAUTH_CONNECTIONS_VESSEL, null) }

    private lateinit var _oauthCredentials: OauthCredentialsPath

    /**
     * Get the implicit to-many join path to the
     * <code>public.oauth_credentials</code> table
     */
    fun oauthCredentials(): OauthCredentialsPath {
        if (!this::_oauthCredentials.isInitialized)
            _oauthCredentials = OauthCredentialsPath(this, null, OAUTH_CREDENTIALS__FK_OAUTH_CREDENTIALS_CONNECTION.inverseKey)

        return _oauthCredentials;
    }

    val oauthCredentials: OauthCredentialsPath
        get(): OauthCredentialsPath = oauthCredentials()

    private lateinit var _oauthConnectionGrants: OauthConnectionGrantsPath

    /**
     * Get the implicit to-many join path to the
     * <code>public.oauth_connection_grants</code> table
     */
    fun oauthConnectionGrants(): OauthConnectionGrantsPath {
        if (!this::_oauthConnectionGrants.isInitialized)
            _oauthConnectionGrants = OauthConnectionGrantsPath(this, null, OAUTH_CONNECTION_GRANTS__FK_OAUTH_GRANTS_CONNECTION.inverseKey)

        return _oauthConnectionGrants;
    }

    val oauthConnectionGrants: OauthConnectionGrantsPath
        get(): OauthConnectionGrantsPath = oauthConnectionGrants()
    override fun getChecks(): List<Check<OAuthConnectionsRecord>> = listOf(
        Internal.createCheck(this, DSL.name("chk_oauth_connections_level"), "(((vessel_id IS NOT NULL) OR (charter_id IS NOT NULL)))", true)
    )
    override fun `as`(alias: String): OAuthConnections = OAuthConnections(DSL.name(alias), this)
    override fun `as`(alias: Name): OAuthConnections = OAuthConnections(alias, this)
    override fun `as`(alias: Table<*>): OAuthConnections = OAuthConnections(alias.qualifiedName, this)

    /**
     * Rename this table
     */
    override fun rename(name: String): OAuthConnections = OAuthConnections(DSL.name(name), null)

    /**
     * Rename this table
     */
    override fun rename(name: Name): OAuthConnections = OAuthConnections(name, null)

    /**
     * Rename this table
     */
    override fun rename(name: Table<*>): OAuthConnections = OAuthConnections(name.qualifiedName, null)

    /**
     * Create an inline derived table from this table
     */
    override fun where(condition: Condition?): OAuthConnections = OAuthConnections(qualifiedName, if (aliased()) this else null, condition)

    /**
     * Create an inline derived table from this table
     */
    override fun where(conditions: Collection<Condition>): OAuthConnections = where(DSL.and(conditions))

    /**
     * Create an inline derived table from this table
     */
    override fun where(vararg conditions: Condition?): OAuthConnections = where(DSL.and(*conditions))

    /**
     * Create an inline derived table from this table
     */
    override fun where(condition: Field<Boolean?>?): OAuthConnections = where(DSL.condition(condition))

    /**
     * Create an inline derived table from this table
     */
    @PlainSQL override fun where(condition: SQL): OAuthConnections = where(DSL.condition(condition))

    /**
     * Create an inline derived table from this table
     */
    @PlainSQL override fun where(@Stringly.SQL condition: String): OAuthConnections = where(DSL.condition(condition))

    /**
     * Create an inline derived table from this table
     */
    @PlainSQL override fun where(@Stringly.SQL condition: String, vararg binds: Any?): OAuthConnections = where(DSL.condition(condition, *binds))

    /**
     * Create an inline derived table from this table
     */
    @PlainSQL override fun where(@Stringly.SQL condition: String, vararg parts: QueryPart): OAuthConnections = where(DSL.condition(condition, *parts))

    /**
     * Create an inline derived table from this table
     */
    override fun whereExists(select: Select<*>): OAuthConnections = where(DSL.exists(select))

    /**
     * Create an inline derived table from this table
     */
    override fun whereNotExists(select: Select<*>): OAuthConnections = where(DSL.notExists(select))
}
